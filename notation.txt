[[Notation]]
== Pourquoi une nouvelle notation

Il existe une notation qui se veut "unifiée" pour les modèles : {uml}.
Néanmoins cette notation est peu adaptée pour l'{is} :

* UML 1.x était complètement inadaptée :
** Principalement pour les systèmes d'information
** Peu de liens entre les diagrammes
** Peu de liens entre les modèles et les exigences

ifdef::backend-slidy2[<<<]

* UML 2.x n'est pas beaucoup mieux si n'est :
** Implication des ingénieurs systèmes pour sa définition
** Introduction du diagramme de structure composite 

ifdef::backend-slidy2[<<<]

En conclusion {UML} est une bonne base :

* Standard _De facto_ en génie logiciel
* Fournit beaucoup de concepts utiles pour décrire des systèmes (même complexes)
* Stable et extensible (grâce notamment au mécanisme de _profile_)
* Beaucoup d'outils disponibles

Mais...

* Manque de certains concepts clés d'{is}
* Vocabulaire beaucoup trop « software » pour être utilisé par les ingénieurs systèmes (concept de +classe+ ou d'+héritage+ par exemple)
* Trop de diagrammes (13 sortes)

== Introduction à SysML

=== Fiche d'identité

- Date de naissance : 2001!
- Version actuelle : 1.3 (2/6/2012)
- Paternité : {OMG}/{UML} + {INCOSE}
- Auteurs principaux
* Conrad Bock
* Cris Kobryn
* Sanford Friedenthal

[NOTE]
.Versions de la spécification de SysML
====
La version 1.0 du langage de modélisation SysML a été adoptée officiellement par l'OMG le 19 septembre 2007. Depuis, trois révisions ont été réalisées :  +1.1+ en décembre 2008, +1.2+ en juin 2010, et +1.3+ en juin 2012.
====

=== Différence avec UML

.Liens entre UML et SysML
image:{images}/diff.png[width="60%"]

=== Qui est "derrière"?

Industrie::
American Systems, BAE Systems, Boeing, Deere & Company, EADS Astrium, Eurostep, Israel Aircraft Industries,  Lockheed Martin, Motorola, NIST, Northrop Grumman, oose.de, Raytheon, Thales, ...

Vendeurs d'outils::
Artisan, EmbeddedPlus, Gentleware, IBM, Mentor Graphics, PivotPoint Technology, Sparx Systems, Vitech, ...

Autres organisations::
AP-233, INCOSE, Georgia Institute of Technology, AFIS, ...

=== Organisation des différents diagrammes

.Les 9 diagrammes SysML et leur lien avec UML
image:{images}/Figure4.1.png[width="90%"]

ifdef::backend-slidy2[<<<]

.Version abrégée des diagrammes
image:{images}/Figure4.1-bis.png[width="90%"]


=== Différence entre modèle et dessin

{SysML} n'est pas une palette de dessins et d'éléments de base servant à faire
des diagrammes. Il existe une représentation graphique des éléments modélisés en {SysML}. Elle est importante car elle permet de communiquer visuellement sur le système en développement, mais du point de vue du concepteur, c'est *le modèle* qui importe le plus. 

C'est pourquoi nous vous recommandons de ne jamais "dessiner" des diagrammes {SysML} footnote:[Sauf bien sûr au brouillon ou sur un tableau, notamment quand on travaille en équipe.], mais d'utiliser des outils dédiés (cf. section <<Outils>>).

ifdef::backend-slidy2[<<<]

Pour ceux qui cherchent à étudier un diagramme en particulier voici un plan de cette section (nous utilisons ici le "plan" vu lors de l'introduction de la <<Matrice>>) :

.Organisation
[cols="h,4*",options="header",width="70%"]
|======================
|				| {Requirements}, cf. <<reqs>> 	| {Structure}, cf. <<archi>>	| {Behavior}, cf. <<behavior>> 	| {Crosscutting}, cf. <<transvers>>
| {organisation}, cf. <<orga>>	|		+pkg+			|     +pkg+, +bdd+   		|		+pkg+		|
| {analysis}, {design}, {implementation} footnote:[En fonction du niveau de détail.]
				|		+req+			|     +bdd+, +ibd+, +seq+, +par+   		| +uc+, +seq+, +st+, +act+				| +par+
|======================

== 	Outils SysML
[[Outils]]

Il existe un certain nombre d'outils permettant de réaliser des modèles SysML. Voici une liste non exhaustive :

* http://www.topcased.org/[TopCased]
* http://www.eclipse.org/modeling/mdt/papyrus/[Papyrus]
* http://www.artisansw.com/[Artisan]
* http://www-01.ibm.com/software/rational/products/rhapsody[Rhapsody]

Vous trouverez sur Internet des comparatifs et des avis à jour sur les outils.

Ce que je voudrai souligner ici c'est l'importance du modèle comme "dépôt" (je préfère le terme anglais de _repository_) d'éléments de base en relation les uns avec les autres. C'est toute la différence entre le dessin et le modèle.

IMPORTANT: Attention toutefois à ne pas confondre ce que vous permet (ou pas) de faire l'outil et la notation elle-même. Les fabricants ont parfois pris des libertés ou bien n'ont pas complètement implémenté toutes les subtilités de la notation.
		
== Principes de base

Abordons quelques principes généraux de {sysml}.

- Chaque diagramme {SysML} représente un élément de modélisation
- Chaque diagramme {SysML} doit être incluse dans un cadre (_Diagram Frame_)
- L'entête du cadre, appelé *cartouche*, indique les informations sur le diagramme:
* le type de diagramme (+req+, +act+, +bdd+, +ibd+, +sd+, etc.)
* le type d'élément (_package_, _block_, _activity_, etc.)
* le nom de l'élément
* le nom du diagramme ou de la vue

ifdef::backend-slidy2[<<<]

Dans l'exemple ci-dessous, le diagramme "_Context_Overview_" est un _Block Definition Diagram_ (type +bdd+) qui représente un
_package_, nommé "Context".  

.Exemple de diagramme SysML
image:{images}/pacemaker-context.png[width="80%"]

== Organisation
[[org]]

.Organisation
[cols="h,4*",options="header",width="50%"]
|======================
|					| {Requirements} 	| {Structure}	| {Behavior} 	| {Crosscutting}
| [red]*{organisation}*	|					|        		|				|
| {analysis}		|					|        		|				|
| {design}			|					|        		|				|
| {implementation}	|					|        		|				|
|======================

=== Fondements

On abordera :

- Le _Package Diagram_
- Les différent types de _packages_
- Les organisations possibles 
- La notion de _Namespaces_
- Les _Dependencies_

=== Le _Package Diagram_

* Identique à {uml}, et classique pour les développeurs (java notamment)
* Permet d'organiser les modèles en créant un espace de nommage (_name space_)

[NOTE]
.Espace de nommage
====
Dans un _package_, on n'a pas à se soucier des noms des éléments. Même si d'autres utilisent les mêmes noms,
il n'y aura pas ambiguité.
====

Les modèles peuvent être organisés selon toutes sortes de considération (cf. <<organisation>>).
Le mécanisme qui permet de les organiser est le _package_ (paquetage).

- hiérarchie "système" (e.g., entreprise, système, composant)
- types de diagrammes (e.g., besoins, structure, comportements)
- par points de vue
- etc.

=== Les différent types de _packages_

Il existe plusieurs types de _package_ :

models:: 
	un _package_ "top-level" dans une hiérarchie de _package_
packages:: 
	le type le plus classique : un ensemble d'éléments de modèles
model librairies:: 
	un _package_ prévu pour être réutilisé (importé) par d'autres éléments 
views:: 
	un _package_ spécial pour représenter les points de vue

[[organisation]]
=== Les organisations possibles 

Les modèles peuvent être organisés selon toutes sortes de considération :

- par hiérarchie "système" (e.g., entreprise, système, composant, ...)
- par types de diagrammes (e.g., besoins, structure, comportements, ...)
- par cycle de vie (e.g., analyse, conception, ...)
- par équipes (e.g., architectes, <<IPT>>, ...)
- par points de vue (e.g., sécurité, performance, ...)
- etc.

ifdef::backend-slidy2[<<<]

.Exemple d'organisation
image:{images}/pkg-organisation2.png[width="60%"]

ifdef::backend-slidy2[<<<]

.Exemple d'organisation
image:{images}/pkg-organisation-modelview.png[width="40%"]

ifdef::backend-slidy2[<<<]

.Exemple d'organisation
image:{images}/pkg-organisation.png[width="40%"]

ifdef::backend-slidy2[<<<]

.Exemple d'organisation
image:{images}/pkg-topcased.png[width="60%"]


=== La notion de _Namespaces_

Un _package_ est un espace de nommage pour tous les éléments qu'il contient.

[NOTE]
====
Dans les outils {sysml}, vous pouvez demander à voir les noms complets (_Qualified names_)
des éléments, c'est à dire le nom de l'élément prefixé par son (ou ses) _package(s)_ 
(e.g., `Structure::Products::Clock`).
====

=== Les dépendances

Un certain nombre de dépendances peuvent exister entre des éléments de _package_
ou entre les _packages_ eux-mêmes :

_Dependency_::
	une dépendance "générale", non précisée, +
	représentée par une simple flèche pointillée `----->`
_Use_::
	l'élément "utilise" celui à l'autre bout de la flèche (un type par exemple), +
	représentée par le stéréotype `≪ use ≫`
_Refine_::
	l'élément est un raffinage (plus détaillé) de celui à l'autre bout de la flèche, +
	représentée par le stéréotype `≪ refine ≫`
_Realization_::
	l'élément est une "réalisation" (implémentation) de celui à l'autre bout de la flèche, +
	représentée par le stéréotype `≪ realize ≫`
_Allocation_::
	l'élément (e.g., une activité ou un _requirement_) est "alloué" sur celui à l'autre bout de la flèche (un +block+ la plupart du temps), +
	représentée par le stéréotype `≪ allocate ≫`

=== {resume}
{sysml} propose un certain nombre de mécanismes pour organiser les différents modèles,
tirés pour la plupart d'{uml}.

=== {revisions}

. Quels sont les 5 types de dépendances entre _packageable elements_ ?
. A quoi sert-il de renseigner les dépendances (donnez des exemples concrets) ?

== Les exigences
[[reqs]]

.Place des Exigences
[cols="h,4*",options="header",width="50%"]
|======================
|					| [red]*{Requirements}* 	| {Structure}	| {Behavior} 	| {Crosscutting}
| {organisation}	|					|        		|				|
| {analysis}		|					|        		|				|
| {design}			|					|        		|				|
| {implementation}	|					|        		|				|
|======================

=== Fondements

On abordera :

- L'organization des _Requirements_ 
- Les _Requirements properties_ 
- Les _Requirements links_ 
- Les _Requirements Diagrams_ 
- Les considerations sur la _Traceability_

=== {resume}

.Déclinaison des Exigences
[cols="h,2,1,1,1",options="header",width="70%"]
|======================
|					| [red]*{Requirements}* 	| {Structure}	| {Behavior} 	| {Crosscutting}
| {organisation}	| +⊕–+, +\<<deriveRqt>>+			|        		|				|
| {analysis}		| +\<<satisfy>>+ entre reqs et UC		|        		|				|
| {design}			| +\<<allocate>>+			|        		|				|
| {implementation}	|	+\<<satisfy>>+, +\<<verify>>+				|        		|				|
|======================

=== {revisions}

- Quelles sont les différences entre *besoins* et *exigences* ?

== L'architecture du système
[[archi]]

.PLace des aspects structurels
[cols="h,4*",options="header",width="50%"]
|======================
|					| {Requirements} 	| [red]*{Structure}*	| {Behavior} 	| {Crosscutting}
| {organisation}	|					|        		|				|
| {analysis}		|					|        		|				|
| {design}			|					|        		|				|
| {implementation}	|					|        		|				|
|======================

=== Fondements

On abordera :

- l'organisation du système et des modèles 
- les _Block Definition Diagrams_ 
- les _Internal Block Diagrams_
- les _Parametric Diagrams_ (pour les contraintes physiques)
- les _Sequence Diagrams_ (diagramme de séquence système) 


=== {resume}
En résumé...

=== {revisions}
Pour réviser...

== Le comportement du système
[[behavior]]

.Place du Comportement
[cols="h,4*",options="header",width="50%"]
|======================
|					| {Requirements} 	| {Structure}	| [red]*{Behavior}* 	| {Crosscutting}
| {organisation}	|					|        		|				|
| {analysis}		|					|        		|				|
| {design}			|					|        		|				|
| {implementation}	|					|        		|				|
|======================

=== Fondements

On abordera :

- les _Use Case Diagrams_ (scénarios) 
- les _Sequence Diagrams_ 
- les _State Machines_
- les _Activity Diagrams_

=== {resume}
En résumé...

=== {revisions}
Pour réviser...

== Les aspects transversaux
[[transvers]]

.Aspects transversaux
[cols="h,4*",options="header",width="50%"]
|======================
|					| {Requirements} 	| {Structure}	| {Behavior} 	| [red]*{Crosscutting}*
| {organisation}	|					|        		|				|
| {analysis}		|					|        		|				|
| {design}			|					|        		|				|
| {implementation}	|					|        		|				|
|======================

=== Fondements

On abordera ici les aspects transversaux comme :

- la traçabilité des exigences indexterm:[Traçabilité]
- les mécanismes d'allocation
- le diagramme paramétrique

=== {resume}
En résumé...

=== {revisions}
Pour réviser...

